#!/bin/bash

#==============================================================================#
#                                                                              #
#                          Philosophers - Unit Tests                           #
#                                                     by: Allan Rabelo (2025)  #
#==============================================================================#


# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Function to display header
display_header() {
	echo -e "${BLUE}"
	echo "╔══════════════════════════════════════╗"
	echo "║          Leaks Tests                 ║"
	echo "╚══════════════════════════════════════╝"
	echo -e "${NC}"
}

# Function to find philosophers directory
find_philo_directory() {
	local possible_paths=(\
		"../philosophers"\
		"../../philosophers"\
		"../philo"\
		"../../philo"\
		"./philosophers"\
		"."\
	)
	
	for path in "${possible_paths[@]}"; do
		if [ -d "$path" ] && [ -f "$path/Makefile" ]; then
			echo "$path"
			return 0
		fi
	done
	
	local found_dir
	found_dir=$(find . -maxdepth 2 -name "Makefile" -type f | head -1 | xargs dirname 2>/dev/null)
	
	if [ -n "$found_dir" ] && [ -d "$found_dir" ]; then
		echo "$found_dir"
		return 0
	fi
	
	return 1
}

# Function to compile with different sanitizers
compile_with_sanitizer() {
	local sanitizer="$1"
	local target="$2"
	
	echo -e "${YELLOW}Compiling with $sanitizer...${NC}"
	
	cd "$PHILO_DIR" || return 1
	
	make clean > /dev/null 2>&1
	
	case $sanitizer in
		"fsanitize")
			if ! make CC="cc -fsanitize=address -fsanitize=leak" re > /dev/null 2>&1; then
				echo -e "${RED}✗ Compilation with fsanitize failed${NC}"
				cd - > /dev/null
				return 1
			fi
			;;
		"normal")
			if ! make re > /dev/null 2>&1; then
				echo -e "${RED}✗ Normal compilation failed${NC}"
				cd - > /dev/null
				return 1
			fi
			;;
	esac
	
	cd - > /dev/null
	echo -e "${GREEN}✓ Compilation with $sanitizer successful${NC}"
	return 0
}

# Function to check for "no leaks are possible" in valgrind output
check_no_leaks_possible() {
	local output="$1"
	
	if echo "$output" | grep -q "no leaks are possible"; then
		return 0
	else
		return 1
	fi
}

# Function to check for any leaks in valgrind output
check_any_leaks() {
	local output="$1"
	
	if echo "$output" | grep -q -E "(definitely lost: [1-9]|indirectly lost: [1-9]|possibly lost: [1-9])"; then
		return 1
	else
		return 0
	fi
}

# Function to check for errors in valgrind output
check_valgrind_errors() {
	local output="$1"
	
	if echo "$output" | grep -q -E "(Invalid read|Invalid write|Use of uninitialised value|Conditional jump)"; then
		return 1
	else
		return 0
	fi
}

# Function to run valgrind test
run_valgrind_test() {
	local test_name="$1"
	local args="$2"
	local description="$3"
	
	echo -e "${PURPLE}Valgrind Test: $test_name${NC}"
	echo -e "Command: ${YELLOW}./philo $args${NC}"
	echo -e "Description: $description"
	
	# Run with valgrind
	local valgrind_output
	valgrind_output=$(timeout 10s valgrind \
		--leak-check=full \
		--show-leak-kinds=all \
		--track-origins=yes \
		--errors-for-leak-kinds=all \
		"$PHILO_EXEC" $args 2>&1)
	
	# Check for "no leaks are possible"
	if check_no_leaks_possible "$valgrind_output"; then
		echo -e "${GREEN}✓ No leaks are possible${NC}"
		local leaks_ok=1
	else
		echo -e "${RED}✗ Leaks detected or 'no leaks are possible' not found${NC}"
		# Show leak summary
		echo "$valgrind_output" | grep -A 10 "HEAP SUMMARY:" | while read line; do
			echo -e "  ${YELLOW}$line${NC}"
		done
		local leaks_ok=0
	fi
	
	# Check for other errors
	if check_valgrind_errors "$valgrind_output"; then
		echo -e "${GREEN}✓ No memory errors${NC}"
		local errors_ok=1
	else
		echo -e "${RED}✗ Memory errors detected${NC}"
		echo "$valgrind_output" | grep -E "(Invalid read|Invalid write|Use of uninitialised value)" | head -3 | while read line; do
			echo -e "  ${YELLOW}$line${NC}"
		done
		local errors_ok=0
	fi
	
	if [ $leaks_ok -eq 1 ] && [ $errors_ok -eq 1 ]; then
		echo -e "${GREEN}✅ VALGRIND TEST PASSED${NC}"
		return 0
	else
		echo -e "${RED}❌ VALGRIND TEST FAILED${NC}"
		return 1
	fi
}

# Function to run helgrind test (thread sanitizer)
run_helgrind_test() {
	local test_name="$1"
	local args="$2"
	local description="$3"
	
	echo -e "${PURPLE}Helgrind Test: $test_name${NC}"
	echo -e "Command: ${YELLOW}./philo $args${NC}"
	echo -e "Description: $description"
	
	# Run with helgrind
	local helgrind_output
	helgrind_output=$(timeout 10s valgrind \
		--tool=helgrind \
		"$PHILO_EXEC" $args 2>&1)
	
	# Check for thread errors
	if echo "$helgrind_output" | grep -q -E "(Possible data race|Lock order violation)"; then
		echo -e "${RED}✗ Threading issues detected${NC}"
		echo "$helgrind_output" | grep -E "(Possible data race|Lock order violation)" | head -3 | while read line; do
			echo -e "  ${YELLOW}$line${NC}"
		done
		echo -e "${RED}❌ HELGRIND TEST FAILED${NC}"
		return 1
	else
		echo -e "${GREEN}✓ No threading issues detected${NC}"
		echo -e "${GREEN}✅ HELGRIND TEST PASSED${NC}"
		return 0
	fi
}

# Function to run fsanitize test
run_fsanitize_test() {
	local test_name="$1"
	local args="$2"
	local description="$3"
	
	echo -e "${PURPLE}FSanitize Test: $test_name${NC}"
	echo -e "Command: ${YELLOW}./philo $args${NC}"
	echo -e "Description: $description"
	
	# Compile with fsanitize
	if ! compile_with_sanitizer "fsanitize" "mandatory"; then
		return 1
	fi
	
	# Run with fsanitize
	local fsanitize_output
	fsanitize_output=$(timeout 10s "$PHILO_EXEC" $args 2>&1)
	local exit_code=$?
	
	# Check for sanitizer errors
	if echo "$fsanitize_output" | grep -q -E "(AddressSanitizer|LeakSanitizer)"; then
		echo -e "${RED}✗ Sanitizer errors detected${NC}"
		echo "$fsanitize_output" | grep -E "(ERROR|Leak)" | head -5 | while read line; do
			echo -e "  ${YELLOW}$line${NC}"
		done
		echo -e "${RED}❌ FSANITIZE TEST FAILED${NC}"
		return 1
	elif [ $exit_code -ne 0 ] && [ $exit_code -ne 124 ]; then
		echo -e "${RED}✗ Program crashed with exit code $exit_code${NC}"
		echo -e "${RED}❌ FSANITIZE TEST FAILED${NC}"
		return 1
	else
		echo -e "${GREEN}✓ No sanitizer issues detected${NC}"
		echo -e "${GREEN}✅ FSANITIZE TEST PASSED${NC}"
		return 0
	fi
}

# Function to run all leak tests on a specific test case
run_complete_leak_test() {
	local test_name="$1"
	local args="$2"
	local description="$3"
	
	echo -e "${CYAN}=== Testing: $test_name ===${NC}"
	echo
	
	local test_passed=1
	
	# Test 1: Valgrind
	if ! run_valgrind_test "$test_name" "$args" "$description"; then
		test_passed=0
	fi
	echo
	
	# Recompile normal for helgrind
	if ! compile_with_sanitizer "normal" "mandatory"; then
		return 1
	fi
	
	# Test 2: Helgrind
	if ! run_helgrind_test "$test_name" "$args" "$description"; then
		test_passed=0
	fi
	echo
	
	# Test 3: FSanitize
	if ! run_fsanitize_test "$test_name" "$args" "$description"; then
		test_passed=0
	fi
	
	echo -e "${CYAN}=== $test_name Complete ===${NC}"
	if [ $test_passed -eq 1 ]; then
		echo -e "${GREEN}✅ ALL LEAK TESTS PASSED${NC}"
	else
		echo -e "${RED}❌ SOME LEAK TESTS FAILED${NC}"
	fi
	echo
	echo "──────────────────────────────────────"
	echo
	
	# CORREÇÃO: Retorna 0 se passou, 1 se falhou (ao contrário do que estava antes)
	return $((1 - test_passed))
}

# Main function
main() {
	display_header
	
	# Find project directory
	PHILO_DIR=$(find_philo_directory)
	if [ -z "$PHILO_DIR" ]; then
		echo -e "${RED}Error: Could not find philosophers project directory${NC}"
		exit 1
	fi
	
	echo -e "${GREEN}✓ Found project at: $PHILO_DIR${NC}"
	
	# Set executable path
	PHILO_EXEC="$PHILO_DIR/philo"
	
	# Initial compilation
	if ! compile_with_sanitizer "normal" "mandatory"; then
		exit 1
	fi
	
	# Check if executable exists
	if [ ! -f "$PHILO_EXEC" ]; then
		echo -e "${RED}Error: philo executable not found at $PHILO_EXEC${NC}"
		exit 1    
	fi
	
	echo -e "${GREEN}✓ philo executable found${NC}"
	echo
	
	local total_tests=0
	local passed_tests=0
	
	echo -e "${BLUE}Starting comprehensive leak tests...${NC}"
	echo -e "${YELLOW}Note: Only testing cases that terminate naturally${NC}"
	echo
	
	# Test cases that terminate naturally
	# Test 1: Single philosopher dies
	if run_complete_leak_test "Single philosopher death" "1 800 200 200" "Philosopher should die without eating"; then
		((passed_tests++))
	fi
	((total_tests++))
	
	# Test 2: With meal count that terminates
	if run_complete_leak_test "Meal count termination" "5 800 200 200 2" "Stop after 2 meals each"; then
		((passed_tests++))
	fi
	((total_tests++))
	
	# Test 3: Quick death
	if run_complete_leak_test "Quick death" "1 200 200 200" "Should die very quickly"; then
		((passed_tests++))
	fi
	((total_tests++))
	
	# Test 4: One death in group
	if run_complete_leak_test "One death in group" "4 310 200 100" "One philosopher should die"; then
		((passed_tests++))
	fi
	((total_tests++))
	
	# Test 5: Small group with meals
	if run_complete_leak_test "Small group with meals" "3 800 200 200 3" "3 philosophers with 3 meals"; then
		((passed_tests++))
	fi
	((total_tests++))
	
	# Test 6: Two philosophers timing
	if run_complete_leak_test "Two philosophers" "2 210 100 100" "Check death timing"; then
		((passed_tests++))
	fi
	((total_tests++))
	
	# Final summary
	echo -e "${BLUE}=== Leaks Tests Summary ===${NC}"
	echo -e "Total test cases: $total_tests"
	echo -e "${GREEN}Passed: $passed_tests${NC}"
	echo -e "Failed: $((total_tests - passed_tests))"
	echo
	
	if [ $passed_tests -eq $total_tests ]; then
		echo -e "${GREEN}=========================================${NC}"
		echo -e "${GREEN}✅ ALL LEAK TESTS PASSED${NC}"
		echo -e "${GREEN}=========================================${NC}"
		exit 0
	else
		echo -e "${RED}=========================================${NC}"
		echo -e "${RED}❌ SOME LEAK TESTS FAILED${NC}"
		echo -e "${RED}=========================================${NC}"
		exit 1
	fi
}

# Run main function
main